\documentclass[smaller,dvipsnames,ratio=169]{beamer}

\usetheme[numbering=fraction,%
          block=fill,%
          sectionpage=progressbar,%
          subsectionpage=progressbar,%
  ]{metropolis} % Use metropolis theme
\setbeamercovered{invisible}

\usepackage[utf8]{inputenc}
%\usepackage[dvipsnames]{xcolor}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{amssymb}
\usepackage{tikz}
  \usetikzlibrary{arrows} % required in the preamble
\usepackage{listings}
\usepackage{todonotes}

\title{SAT Solver Front-End}
\subtitle{Team White Report}
\author{Filippo~De~Bortoli \and Aneta~Koleva \and Lorenz~Leutgeb}
\institute{Free University of Bozen-Bolzano\\[2mm] \texttt{\{\href{mailto:filippo.debortoli@stud-inf.unibz.it}{filippo.debortoli},\href{mailto:aneta.koleva@stud-inf.unibz.it}{aneta.koleva},\href{mailto:lorenz.leutgeb@stud-inf.unibz.it}{lorenz.leutgeb}\}\newline @stud-inf.unibz.it}}
\date{2018-04-20}

\begin{document}

  \maketitle

  \begin{frame}{Outline}
    \tableofcontents
  \end{frame}

  \section{Introduction}

  \begin{frame}{Task}
	\begin{enumerate}
		\item Given a grammar for a Boolean logic language with standard connectives and quantifiers over finite domains.
		\item Develop an optimizing compiler that translates input formulae into CNF.
		\item Interface with a SAT solver to compute models for input formulae.
	\end{enumerate}
  \end{frame}

  \begin{frame}{Tools of the Trade}
	\begin{enumerate}
		\item Pragmatic choices to avoid any confusions
		\item Keeping it DRY (Don't Repeat Yourself)
		\item Avoid reinvention
	\end{enumerate}

  	\begin{center}
  	\begin{tabular}{lll}
  		{\bfseries Tool/Library} & {\bfseries Version} & {\bfseries Purpose} \\
  		ANTLR & 4.7.1 & Parser Generator \\
  		Java & 10 & Runtime \\
  		SAT4J & 2.3.5 & Solver Components \\
  		Guava & & Utilities and Data Structures \\
  		JCommander & & Commandline Parsing \\
  		JUnit & 5.1 & Testing \\
  		LOG4J & & Logging \\
  		Gradle & 4.6 & Dependency and Build Management \\
  	\end{tabular}
  	\end{center}
  \end{frame}

  \section{Front-end architecture}

  \begin{frame}{Big Picture}
    % Panorama on the whole front-end.
    % Here, names only. Descriptions in next slides.
    
    \begin{tabular}{lll}
1 & Parser & $(\exists x \in \{a, b\}) \neg (\exists y \in \{c, d\}) (p(x) \land p(y))$ \\
2 &Compilation Passes & \\
2a & ~ Normalization & (to only have $\land, \lor, \neg$)\\
2b & ~ NNF &$ (\exists x {\in} \{a, b\}) (\forall y {\in} \{c, d\}) (\neg p(x) \lor \neg p(y))$ \\
2b & ~ Standarization &$ (\exists x_1 {\in} \{a, b\}) (\forall x_2 {\in} \{c, d\}) (\neg p(x_1) \lor \neg p(x_2))$ \\
2c & ~ Push and Reorder Qs&$ (\forall x_2 {\in} \{c, d\}) (\exists x_1 {\in} \{a, b\}) (\neg p(x_1) \lor \neg p(x_2))$ \\
3 & Ground &$ (\neg p(a) \lor \neg p(c) \lor \neg p(b)) \land \dots$ \\
4 & Tseitin Transformation \\
5 & CNF Minimization \\
5a & ~ Unit Propagation \\
5b & ~ Hole Elimination & (in case unit propagation is successful)\\
6 & DIMACS Generation \\
    \end{tabular}
  \end{frame}

  \begin{frame}{Parser}
  	\begin{enumerate}
  		\item We don't always need to parse languages\dots \newline But when we do, we use a parser generator (like ANTLR).
  		\item Straightforward parser generation as build step with Gradle: \texttt{gradle~generateGrammarSource}
  		\item At runtime use ANTLR API and consume parse tree.
  		\item Map parse tree into our custom AST representation which implements compilation passes.
  	\end{enumerate}
  \end{frame}

  \begin{frame}{Clause Accumulator}
  	\begin{itemize}
	  	\item Bookkeeping during Tseitin Transformation
	  	\item Store clauses
  		\item Which proposition maps to which high level expression?
	  	\item Pass on clauses to a 2WL container (borrowed from SAT4J)
	  	\item Once transformation is done, compress using Unit Propagation and Hole Elimination
  	\end{itemize}
  \end{frame}

  % Add one slide per each relevant class.

  \section{Algorithms and Design Choices}

  \begin{frame}{Optimized CNF}
  	\begin{itemize}
  		\item Use implications only (we always are in a positive context thanks to NNF).
  		\item Structural Sharing
  	\end{itemize}
    % Describe employed optimizations. May need several slides.
  \end{frame}

  \begin{frame}{Unit Propagation}
  	\begin{itemize}
  		\item Re-use components of SAT4J (2WL, partial Assignment, \texttt{UnitPropagationListener})
  		\item Add unit clauses for propositions that correspond to atoms in the high level formula in case they were eliminated by UP.
  	\end{itemize}
    % Describe how unit propagation is done. Join with optimized CNF?
  \end{frame}

  \begin{frame}{Other}
    % As well, one/more slides for each relevant piece of machinery.
  \end{frame}
  
  \begin{frame}[fragile]{Extensions}
  	\begin{itemize}
  		\item Term (In)equality
  		\item Comparison of Integer Expressions
  	\end{itemize}
  	\begin{verbatim}
expression
: ...

| left=intExpression
    op=(GT|LT|GE|LE|NE|EQ)
  right=intExpression
# arithmeticAtom

| left=term op=(NE|EQ) right=term
# equalityAtom

;
  	\end{verbatim}
\end{frame}

  \section{Evaluation}

  \begin{frame}
    \frametitle{The Test Suite}
    Powered by \alert{JUnit}.

    Instance types:
    \begin{itemize}
      \item 22 propositional formulas \textcolor{lightgray}{connectives, known equivalences}
      \item 24 non-ground formulas \textcolor{lightgray}{integers with related built-ins, characters}
      \item 4 complex encodings \textcolor{lightgray}{Sudoku, nested quantifiers optimization}
    \end{itemize}
    Asserted results:
    \begin{itemize}
      \item \alert{Size} of generated CNF \textcolor{lightgray}{\# clauses and \# variables}
      \item Number of \alert{models}
    \end{itemize}
    Execution \alert{time} is measured.
  \end{frame}

  \begin{frame}
    \frametitle{Results}
    \missingfigure[]{Plot of the collected data (not produced yet).}
    % Showing improvement over time?
    % wrt generated clauses and literals.
  \end{frame}

  \begin{frame}{Possible Improvements}
  	\begin{itemize}
  		\item Combine multiple optimization passes into one (currently separated for clarity).
  		\item Further optimization that we have missed.
  		\item Initialize solver to use pre-filled 2WL datastrcture.
  		\item String Terms (access length, define concatenation).
  		\item Other solvers as back-ends.
  		\item Syntax Highlighting in REPL.
  		\item Rewrite the whole thing.
  		\item Use a faster runtime than Java (go native).
  		\item Generate CNF and propagate in parallel.
  	\end{itemize}
  \end{frame}

  \section{Conclusion}

  % Here, a recap. Right?

  \begin{frame}[standout]
    Thank you!
  \end{frame}

\end{document}