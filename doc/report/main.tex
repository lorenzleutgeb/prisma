\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{csquotes}

\title{Prisma: A SAT Solver Front-End}
\subtitle{Project Report}
\author{Team White\\[2mm]Filippo~De~Bortoli \and Aneta~Koleva \and Lorenz~Leutgeb}
\institute{Free University of Bozen-Bolzano\\[3mm] \texttt{\{\href{mailto:filippo.debortoli@stud-inf.unibz.it}{filippo.debortoli},\href{mailto:aneta.koleva@stud-inf.unibz.it}{aneta.koleva},\href{mailto:lorenz.leutgeb@stud-inf.unibz.it}{lorenz.leutgeb}\}\newline @stud-inf.unibz.it}}

\begin{document}

  \maketitle

  \begin{abstract}
We present an implementation of an optimizing compiler that translates formulae in a high-level language of logical expressions (common Boolean connectives, quantification of integer expressions, symbolic terms and predicates over finite domains) into ground formulae in CNF. It interfaces with a SAT solver to compute models where propositions correspond to atoms in the high-level input. The resulting Java program is called \enquote{Prisma}.
  \end{abstract}

%\input{sections/introduction}
%\input{sections/architecture}
%\input{sections/algorithms}
%\input{sections/evaluation}
%\input{sections/conclusion}

In this brief report we want expand on the presentation given in the laboratory session. Please reconsider our slides, available via \url{https://lorenz.leutgeb.xyz/tmp/prisma-beam.pdf}. The content is augmented by pointers to the codebase (by means of class names and method names), instructions on how to obtain an executable version of Prisma, and some guidance on how to run it.

This report is structured as follows: In Section \ref{sec:code} we explain how to obtain the source code of our implementation in order to point to specific classes and methods in Section \ref{sec:arch} where we give a sketch of the architecture. Section \ref{sec:buildnrun} is concerned with getting Prisma to run, by building yourself (Section \ref{sec:build}) or by using a pre-built JAR (Section \ref{sec:run}). Then, in Section \ref{sec:usage}, we introduce commandline options for Prisma. Finally, in Section \ref{sec:output} we describe the output format.

\section{Codebase}
\label{sec:code}

Please use the Git repository hosted at \url{https://gitlab.inf.unibz.it/ILS/ils-2018/white}. You should have access as a reporter, for more information on permissions see \url{https://gitlab.inf.unibz.it/help/user/permissions#project-members-permissions}. You are welcome to file issues on GitLab!

In the following section we shorten package names and refer to them relative to the Java package \texttt{it.unibz.stud\_inf.ils.white.prisma}, the source root of which is \texttt{src/main/java}, relative to the project root, which is \texttt{Projects/prisma}, relative to the repository root.

\section{Architecture}
\label{sec:arch}

The following list gives a picture of the flow of information through our implementation. It starts with the 

\begin{enumerate}
	\item{\textbf{Parser} generated by ANTLR and instrumented using the ANTRL runtime API (see \texttt{parser.Parser})}
	\item{\textbf{Normalizing and Optimizing Passes} (implemented in \texttt{ast.Expression} and its subclasses)
		\begin{enumerate}
			\item{\textbf{Normalization} (see \texttt{\#normalize})}
			\item{\textbf{Negation Normal Form} (see \texttt{\#normalize})}
			\item{\textbf{Standardization} (see \texttt{\#standardize})}
			\item{\textbf{Push and Reorder Quantifiers} (see \texttt{\#pushDown})}
		\end{enumerate}
	}
	\item{\textbf{Grounding} (implemented by \texttt{ast.Expression\#ground})}
	\item{\textbf{Tseitin Transformation} (implemented by \texttt{ast.Expression\#tseitin} using \texttt{cnf.ClauseAccumulator} for bookkeeping)}
	\item{CNF Minimization (implemented in \texttt{cnf.ClauseAccumulator\#compress})
		\begin{enumerate}
			\item{Unit Propagation}
			\item{Hole Elimination}
		\end{enumerate}
	}
	\item{\textbf{DIMACS Generation} or \textbf{Solving} (see \texttt{cnf.DIMACSCNF})}
\end{enumerate}

\section{Building and Running Prisma}
\label{sec:buildnrun}

We first explain the prerequisites to run Prisma and how to obtain an executable version in the following. Then, commandline arguments are described.

\subsection{Building from Source}
\label{sec:build}

Prisma can be built using ANTLR (to generate the parser) and \texttt{javac}, the standard Java compiler. However, we strongly recommend the build tool Gradle, avilable from \url{https://gradle.org}, which was used to develop Prisma. In order to build Prisma the following two Gradle tasks need to be executed: \texttt{generateGrammarSource} (to generate the parser) and \texttt{build} (or optionally \texttt{bundleJar} to obtain a packaged JAR file).

\subsection{Running a Pre-Built Executable Version}
\label{sec:run}

\begin{enumerate}
	\item{Ensure that a Java Runtime Environment in version 8 or higher is installed on your machine. To do this, you may run the following command:
	\begin{verbatim}
	$ java -version
	\end{verbatim}
	This should print a version number. For example: \texttt{java~version~"10"} (Java 10) or \texttt{java~version~"1.8.0\_162"} (Java 8u162), both of which are suitable to run Prisma. In case the command is not found, please first install a Java Runtime Environment (there are numerous tutorials and packages for many Linux distributions available online).
	}
	\item{Download a packaged version of Prisma from
	\begin{center}
	\url{https://lorenz.leutgeb.xyz/tmp/prisma.jar}
	\end{center} and let the location of the file be denoted as \texttt{\$PRISMA} in the following.}
	\item{You may run Prisma as follows:
	\begin{verbatim}
	$ java -jar $PRISMA
	\end{verbatim}
	}

\section{Commandline Usage}
\label{sec:usage}

Prisma offers four different modes of operation, which roughly correspond to the type of output it is expected to emit:

\begin{description}
	\item[\texttt{CNF}]{Emit a formula that is equisatisfiable with the input formula in the same language as the input languge.}
	\item[\texttt{DIMACS}]{Emit a SAT instance in DIMACS format, including comments that encode which propositional variable maps to which high-level atom.}
	\item[\texttt{SOLVE}]{Print models of the input formula, or \texttt{UNSATISFIABLE} if there are none. In this mode, Prisma additonally accepts the parameter \texttt{models} to specify how many models should be computed (by default at most one model will be computed).}
	\item[\texttt{REPL} \textnormal{(default)}]{Starts a Read Evaluate Print Loop (REPL) for more fine-grained interaction scenarios.}
\end{description}

\subsection{Examples}

To read a formula from \texttt{f.in} and print an equisatisfisble formula in CNF:

	\begin{verbatim}
	$ java -jar $PRISMA -mode CNF f.in
	\end{verbatim}

To read a formula from \texttt{f.in} and print its DIMACS representation to \texttt{f.dimacs}:

	\begin{verbatim}
	$ java -jar $PRISMA -mode DIMACS f.in f.dimacs
	\end{verbatim}


To read a formula from standard input and write its DIMACS representation to standard output:

	\begin{verbatim}
	$ java -jar $PRISMA -mode DIMACS
	\end{verbatim}
	
To compute at most 10 models for a formula in \texttt{f.in} and print models to standard output:

	\begin{verbatim}
	$ java -jar $PRISMA -mode SOLVE -models 10 f.in
	\end{verbatim}

To interactively experiment:

	\begin{verbatim}
	$ java -jar $PRISMA
	\end{verbatim}
	
\section{Output Format}
\label{sec:output}

Since the input format is well specified we focus on the specification of output format(s) only.

\subsection{\texttt{DIMACS} Mode}

The output is compatible with the DIMACS format. Above the problem line, Prisma prints lines of the form:

	\begin{verbatim}
	c map <integer> <atom>
	\end{verbatim}

Which indicate that the propositional variable denoted by the integer number represents the atom in the high-level language. For example:

\begin{verbatim}
$ echo 'forall $x in {s, t} p($x) | q($x)' \
| java -jar prisma.jar -mode DIMACS    
c Generated by Prisma
c Team White
c map 1 p(s)
c map 2 q(s)
c map 3 p(t)
c map 4 q(t)
p cnf 4 2
1 2 0
3 4 0

\end{verbatim}

\subsection{\texttt{SOLVE} Mode}

The output of this mode is inspired by the ASP solver DLV. In case the input formula is unsatisfiable, Prisma prints a single line \texttt{UNSATISFIABLE}. Otherwise, one model per line is printed. Each model is prefixed with \texttt{\{} and postfixed with \texttt{\}} while true atoms are delimited by \texttt{,}. For example:

\begin{verbatim}
	$ echo 'forall $x in {s, t} p($x) | q($x)' \
	| java -jar prisma.jar -mode SOLVE -models 9
{p(t), q(s)}
{p(t), q(s), q(t)}
{q(s), q(t)}
{p(s), q(s), q(t)}
{p(s), p(t)}
{p(s), p(t), q(s)}
{p(s), p(t), q(s), q(t)}
{p(s), q(t)}
{p(s), p(t), q(t)}
\end{verbatim}

\begin{verbatim}
	$ echo 'true & false' \
	| java -jar prisma.jar -mode SOLVE
UNSATISFIABLE
\end{verbatim}

\end{enumerate}
\end{document}